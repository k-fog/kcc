# 開発ログ

## 教科書
- [低レイヤを知りたい人のためのCコンパイラ作成入門（CompilerBook）](https://www.sigbus.info/compilerbook#)
- [新・標準プログラマーズライブラリC言語 ポインタ完全制覇（ポインタ完全制覇）](https://gihyo.jp/book/2017/978-4-7741-9381-6)

## 2025-07-02
- 電卓コンパイラができた
  - 四則演算
  - 括弧による優先順位付け
  - 単項`+`/`-`
- Pratt Parsing
  - https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html
  - https://github.com/bradford-hamilton/monkey-lang/blob/master/parser/parser.go
  - https://github.com/TheAlukard/Pratt-Parsing

## 2025-07-03
- 比較演算子を実装した
- 単項`!`
  - !x <=> x==0
  - x86_64の`cmp`っていろいろなオペランドをとれるのか、すごい
- 代入演算子`=`の構文解析
  - `=`は右結合なのでこのままではうまくいかない
  - YouTubeで[Pratt Parsingのわかりやすいアニメーションと解説](https://youtu.be/0c8b7YfsBKs?si=caL7g6vM6oz02IS4)を見つけた
  - 演算子ごとに左結合か右結合かを指定することでパースできた
- '1<2<3'みたいなのがコンパイルできてしまう
- codegenは明日やる

```sh
% ./kcc 'a=b=1+2+3'
a       TokenTag=15
=       TokenTag=0
b       TokenTag=15
=       TokenTag=0
1       TokenTag=14
+       TokenTag=1
2       TokenTag=14
+       TokenTag=1
3       TokenTag=14
        TokenTag=16
(= a (= b (+ (+ 1 2) 3)))
```

## 2025-07-04
- `NodeList`構造体を作った
- 複数の文`stmt := (expr ';')*`をパースできた
- [CompilerBook ステップ9：1文字のローカル変数](https://www.sigbus.info/compilerbook#ステップ91文字のローカル変数)を読んだ
- テストが通らないと思ったら変数のスタックのアドレス計算式（e.g. rbp-8, rbp-16）が間違ってた
- 1文字のローカル変数を使ったプログラムが動いた。`a=1;b=2;a+b; => 3`

## 2025-07-05
- Lexerで識別子を切り出す処理がバグってる。1文字の時はうまく動いていたけど複数文字になると動かない
  - while文の条件が間違っていた。なぜ今まで気づかなかった…
- 複数文字のローカル変数が使えるようになった
- 'return'キーワードを追加
- `1 2 3;`みたいな誤ったプログラムでエラーを出せるように`is_infix`関数を追加し、構文解析時にチェックする
  - `enum OpPrecedence`に`PREC_NONE = 0`を追加
  - `precedences`配列をトークンの種類数だけ確保するように変更、
    グローバル変数は0で初期化されるので、優先度を指定したトークン以外は`PREC_NONE`になる
  - `precedences[tag]`が`PREC_NONE`か否かで判定
- 関数呼び出しのパースを実装した
  ```sh
  % ./kcc 'func(a, b+c, d);'
  (func a (+ b c) d)
  ```
- `make debug`をできるようにした。
  debug用にビルドしたバイナリの場合は、テストを走らせる前に手動で`make clean`をする

## 2025-07-06
- `printf("%.*s", len, ptr)`で出力する文字列の長さを指定できるらしいので、この書き方に統一
- 引数6個までの関数呼び出しができた
  - ~~TODO~~
    > 関数呼び出しをする前にRSPが16の倍数になっていなければいけません。
  - push/popでrspは8ずつ増減する。カウントする必要がありそう
  - gccを参考にローカル変数のために確保するスタックサイズを16の倍数にアラインメントするよう変更
- if文を実装

## 2025-07-07
- blockを実装

## 2025-07-09
- `gen_stmt`で使うラベルidが被るバグを修正
- while文を追加
- for文を追加
- 関数定義を実装！動いた！
  - Parserは、いまパースしている関数のノード`current_func`を持つ
  - ローカル変数の情報localsは関数ノードが持つことにした
  - 仮引数もローカル変数と同様に扱った
  - TODO: ABIを調べる
  - TODO: 構文解析でセグフォする前にエラーを出したい
    - ブロックの閉じ括弧がないとき
```
fib(n) {
    if(n<=1) return n;
    else return fib(n-1) + fib(n-2);
}
main(){ fib(10); } // => 55
```

## 2025-07-10
- gccの`*=`
  - かける数が定数かつ2の累乗のときは左シフト`sal`に
  - かける数が定数かつ2の累乗に近いときは`sal`と`add`,`sub`の組み合わせにコンパイルされる
  - それ以外は`imul`
  - （とりあえずkccでは全部`imul`にする）
- `+=`,`-=`を実装
- `*=`,`/=`を実装
- RAX, RCX, RDX, RSI, RDI, R8-R11あたりは、caller-saveなので勝手に使ってよさそう
- コメントを実装。字句解析で読み飛ばす

## 2025-07-12
- 単項`&`,`*`を追加。実装はとても楽だった。ポインタ完全に理解した
- 関数呼び出しの時rspを16の倍数にアラインメント
  - ~~rspをpushするとそこでrspが-8されるため、復帰時に+8する必要がある~~
    - 再帰呼び出しでバグった
    - アラインメントを補正する必要がある場合とない場合の2通りの`call`を出力することにした

## 2025-07-13
- 『ポインタ完全制覇』が届いたので、1章を読んだ
- `int`キーワード
- 型を見る（`int` or ポインタ）
  - ポインタ
  - まだ、見ただけで使ってない
- 左辺にderefがある代入文をサポート
- ポインタ型の加算・減算に対応
  - exprを組み立ててから、型チェックをする方針
  - ポインタ型の場合は足す数／引く数を4倍する->`typed_expr`関数
  - ~~直接ASTを編集する~~
  - codegenで対応する方針に変更
  - ~~TODO~~: ptr-ptr
  - `typed_expr`あたりがあんまり綺麗でない気がする
- 学びメモ：intの本音はレジスタの幅ということを踏まえると、汎整数昇格は結構自然な仕様

## 2025-07-14
- `sizeof`演算子を追加
- 『ポインタ完全制覇』を眺める
  - p.186, Fig.3-11 を見て、Nodeに型情報を持たせている現在の実装でよさそうと感じた

## 2025-07-15
- chibiccを参考にリファクタリング
  - 型関係のコードを別ファイル`type.c`に分離したい
- 根ノードを渡すと全ての子ノードを再帰的に型付けする`typed`関数を追加
  - ついでに型の整合性をチェックする
- TODO: `+=`,`-=`のポインタ演算対応
- TODO: 関数の返り値の型チェック
```
  321 codegen.c
  160 kcc.h
  181 lexer.c
  178 main.c
  453 parser.c
  134 type.c
 1427 total
```
- codegenから不要なコードの出力を削った

## 2025-07-18
- 配列の宣言を追加
- 配列アクセスを追加（`a[i]`は、`*(a+i)`の糖衣構文）
- int型の変数を4byteとして、load/storeするときにサイズを考慮するようにした
- 段々、コードが複雑になっているためリファクタリングを進めたい

## 2025-07-19
- 後置演算子のパースを`expr_postfix`関数にまとめた

## 2025-07-21
- 指摘 ~~TODO~~
  - `int - ptr` はできない
- グローバル変数を追加
- 書き込み可能／不可能`.data`, `.text`
- `ptr - ptr`ができた
  - TODO: 場合分けをもうちょっときれいにしたい
- char型を追加した
  - 汎整数昇格の実装はこれでいいのか？（2025-07-23追記：だいぶ間違ってた）
  - char型に関するテストを書いているときに`ch`という関数を定義するとアセンブラがエラーを出して、
    調べてみたらレジスタと名前が衝突してた… TODO:ラベル命名の修正
- 文字列リテラルのtokenizeだけ
  - TODO: エスケープシーケンス

## 2025-07-22
- codegen.cの`gen_expr`関数を分割

## 2025-07-23
- 文字列型を追加
  - 文字列が出てきたらParserの`string_tokens`リストに追加。インデックスをIDとする。インデックスはノードに保存しておく
  - 文字列はchar型の配列
  - 式の中で配列は先頭要素へのポインタに読み替えられる
- 計算するときにcharをintに読み替えるようにする
- `typed`関数を修正

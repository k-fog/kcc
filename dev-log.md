# 開発ログ

## 教科書
- [低レイヤを知りたい人のためのCコンパイラ作成入門（CompilerBook）](https://www.sigbus.info/compilerbook#)
- [新・標準プログラマーズライブラリC言語 ポインタ完全制覇（ポインタ完全制覇）](https://gihyo.jp/book/2017/978-4-7741-9381-6)

## 2025-07-02
- 電卓コンパイラができた
  - 四則演算
  - 括弧による優先順位付け
  - 単項`+`/`-`
- Pratt Parsing
  - https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html
  - https://github.com/bradford-hamilton/monkey-lang/blob/master/parser/parser.go
  - https://github.com/TheAlukard/Pratt-Parsing

## 2025-07-03
- 比較演算子を実装した
- 単項`!`
  - !x <=> x==0
  - x86_64の`cmp`っていろいろなオペランドをとれるのか、すごい
- 代入演算子`=`の構文解析
  - `=`は右結合なのでこのままではうまくいかない
  - YouTubeで[Pratt Parsingのわかりやすいアニメーションと解説](https://youtu.be/0c8b7YfsBKs?si=caL7g6vM6oz02IS4)を見つけた
  - 演算子ごとに左結合か右結合かを指定することでパースできた
- '1<2<3'みたいなのがコンパイルできてしまう
- codegenは明日やる

```sh
% ./kcc 'a=b=1+2+3'
a       TokenTag=15
=       TokenTag=0
b       TokenTag=15
=       TokenTag=0
1       TokenTag=14
+       TokenTag=1
2       TokenTag=14
+       TokenTag=1
3       TokenTag=14
        TokenTag=16
(= a (= b (+ (+ 1 2) 3)))
```

## 2025-07-04
- `NodeList`構造体を作った
- 複数の文`stmt := (expr ';')*`をパースできた
- [CompilerBook ステップ9：1文字のローカル変数](https://www.sigbus.info/compilerbook#ステップ91文字のローカル変数)を読んだ
- テストが通らないと思ったら変数のスタックのアドレス計算式（e.g. rbp-8, rbp-16）が間違ってた
- 1文字のローカル変数を使ったプログラムが動いた。`a=1;b=2;a+b; => 3`

## 2025-07-05
- Lexerで識別子を切り出す処理がバグってる。1文字の時はうまく動いていたけど複数文字になると動かない
  - while文の条件が間違っていた。なぜ今まで気づかなかった…
- 複数文字のローカル変数が使えるようになった
- 'return'キーワードを追加
- `1 2 3;`みたいな誤ったプログラムでエラーを出せるように`is_infix`関数を追加し、構文解析時にチェックする
  - `enum OpPrecedence`に`PREC_NONE = 0`を追加
  - `precedences`配列をトークンの種類数だけ確保するように変更、
    グローバル変数は0で初期化されるので、優先度を指定したトークン以外は`PREC_NONE`になる
  - `precedences[tag]`が`PREC_NONE`か否かで判定
- 関数呼び出しのパースを実装した
  ```sh
  % ./kcc 'func(a, b+c, d);'
  (func a (+ b c) d)
  ```
- `make debug`をできるようにした。
  debug用にビルドしたバイナリの場合は、テストを走らせる前に手動で`make clean`をする

## 2025-07-06
- `printf("%.*s", len, ptr)`で出力する文字列の長さを指定できるらしいので、この書き方に統一
- 引数6個までの関数呼び出しができた
  - ~~TODO~~
    > 関数呼び出しをする前にRSPが16の倍数になっていなければいけません。
  - push/popでrspは8ずつ増減する。カウントする必要がありそう
  - gccを参考にローカル変数のために確保するスタックサイズを16の倍数にアラインメントするよう変更
- if文を実装

## 2025-07-07
- blockを実装

## 2025-07-09
- `gen_stmt`で使うラベルidが被るバグを修正
- while文を追加
- for文を追加
- 関数定義を実装！動いた！
  - Parserは、いまパースしている関数のノード`current_func`を持つ
  - ローカル変数の情報localsは関数ノードが持つことにした
  - 仮引数もローカル変数と同様に扱った
  - TODO: ABIを調べる
  - TODO: 構文解析でセグフォする前にエラーを出したい
    - ブロックの閉じ括弧がないとき
```
fib(n) {
    if(n<=1) return n;
    else return fib(n-1) + fib(n-2);
}
main(){ fib(10); } // => 55
```

## 2025-07-10
- gccの`*=`
  - かける数が定数かつ2の累乗のときは左シフト`sal`に
  - かける数が定数かつ2の累乗に近いときは`sal`と`add`,`sub`の組み合わせにコンパイルされる
  - それ以外は`imul`
  - （とりあえずkccでは全部`imul`にする）
- `+=`,`-=`を実装
- `*=`,`/=`を実装
- RAX, RCX, RDX, RSI, RDI, R8-R11あたりは、caller-saveなので勝手に使ってよさそう
- コメントを実装。字句解析で読み飛ばす

## 2025-07-12
- 単項`&`,`*`を追加。実装はとても楽だった。ポインタ完全に理解した
- 関数呼び出しの時rspを16の倍数にアラインメント
  - ~~rspをpushするとそこでrspが-8されるため、復帰時に+8する必要がある~~
    - 再帰呼び出しでバグった
    - アラインメントを補正する必要がある場合とない場合の2通りの`call`を出力することにした

## 2025-07-13
- 『ポインタ完全制覇』が届いたので、1章を読んだ
- `int`キーワード
- 型を見る（`int` or ポインタ）
  - ポインタ
  - まだ、見ただけで使ってない
- 左辺にderefがある代入文をサポート
- ポインタ型の加算・減算に対応
  - exprを組み立ててから、型チェックをする方針
  - ポインタ型の場合は足す数／引く数を4倍する->`typed_expr`関数
  - ~~直接ASTを編集する~~
  - codegenで対応する方針に変更
  - ~~TODO~~: ptr-ptr
  - `typed_expr`あたりがあんまり綺麗でない気がする
- 学びメモ：intの本音はレジスタの幅ということを踏まえると、汎整数昇格は結構自然な仕様

## 2025-07-14
- `sizeof`演算子を追加
- 『ポインタ完全制覇』を眺める
  - p.186, Fig.3-11 を見て、Nodeに型情報を持たせている現在の実装でよさそうと感じた

## 2025-07-15
- chibiccを参考にリファクタリング
  - 型関係のコードを別ファイル`type.c`に分離したい
- 根ノードを渡すと全ての子ノードを再帰的に型付けする`typed`関数を追加
  - ついでに型の整合性をチェックする
- TODO: `+=`,`-=`のポインタ演算対応
- ~~TODO~~: 関数の返り値の型チェック
```
  321 codegen.c
  160 kcc.h
  181 lexer.c
  178 main.c
  453 parser.c
  134 type.c
 1427 total
```
- codegenから不要なコードの出力を削った

## 2025-07-18
- 配列の宣言を追加
- 配列アクセスを追加（`a[i]`は、`*(a+i)`の糖衣構文）
- int型の変数を4byteとして、load/storeするときにサイズを考慮するようにした
- 段々、コードが複雑になっているためリファクタリングを進めたい

## 2025-07-19
- 後置演算子のパースを`expr_postfix`関数にまとめた

## 2025-07-21
- 指摘 ~~TODO~~
  - `int - ptr` はできない
- グローバル変数を追加
- 書き込み可能／不可能`.data`, `.text`
- `ptr - ptr`ができた
  - ~~TODO~~: 場合分けをもうちょっときれいにしたい
- char型を追加した
  - 汎整数昇格の実装はこれでいいのか？（2025-07-23追記：だいぶ間違ってた）
  - char型に関するテストを書いているときに`ch`という関数を定義するとアセンブラがエラーを出して、
    調べてみたらレジスタと名前が衝突してた… TODO:ラベル命名の修正
- 文字列リテラルのtokenizeだけ
  - TODO: エスケープシーケンス

## 2025-07-22
- codegen.cの`gen_expr`関数を分割

## 2025-07-23
- 文字列を追加
  - 文字列が出てきたらParserの`string_tokens`リストに追加。インデックスをIDとする。インデックスはノードに保存しておく
  - 文字列はchar型の配列
  - 式の中で配列は先頭要素へのポインタに読み替えられる
- 計算するときにcharをintに読み替えるようにする
- `typed`関数を修正
- 関数が返す型を考慮するようになった
  - 関数の名前と返す値をメモっておき、型チェック時に利用
  - 知らない関数は`int`型を返すと仮定
- テストケースの修正
- `sizeof(int)`, `sizeof(char)`を書けるようにした
  - ~~TODO~~: `sizeof(int*)`
- 文字列の長さを考えるとき'\0'を忘れていたため修正

## 2025-07-24
- `Var`という構造体に関数の情報を保存するのはあまり見栄えがよくないため、`Symbol`にリネーム
  - 記号表（symbol table）を意識して命名したが、もっといい名前を思いついたら変更したい
- 関数がポインタ型を返すことを確かめるテストを追加

| step／データ | トークン | AST | 関数返り値型表 | ローカル変数表 | グローバル変数表 | 文字列表 |
| - | - | - | - | - | :- | - |
| 字句解析 | 作る | - | - | - | - | - |
| 構文解析 | 〇 | 作る | 作る | 作る | 作る | 作る |
| 意味解析（型チェック） | 〇 | 〇 | 〇 | 〇 | 〇 | × |
| アセンブリコード生成 | 〇 | 〇 | × | 〇 | 〇 | 〇 |

- `parse`関数の返り値を`struct Program`としてまとめた
- `sizeof(int*)`のようなポインタ型に対する`sizeof`を追加
- ソースコードの入力をファイルからの入力 or 標準入力に変更

## 2025-07-26
- ローカル変数の宣言と初期化ができるようになった
  - declarationの構文が難しい…
  - とりあえず動くものを作ることを優先
- ~~TODO~~: 配列の配列、括弧を使った優先順位付け
  - 2時間くらい試行錯誤した（wipとしてコミットしたやつ）が、うまくいかなかったのでCompilerBookをちゃんと読み直すと以下の記述を見つけた
  - > ネストした型がある場合、カッコの中の型と外の型を別々に構文解析して、後でそれを組み合わせることにより、全体の型を得ることができます。（CompilerBook Cの型の構文）
  - さらに1時間くらいコードを書いたが完成しなかったので他の人のコードを見て学ぶことにした
  - [9ccのパーサ](https://github.com/rui314/9cc/blob/ea2f4b8bdedef70dc9e1dcbf99c255c94e0fa2fe/parse.c#L654)を参考にして実装できた
  - と思ったら`int (hoge);`みたいな（別にいらない）括弧が付いた宣言が通らない
    - 別にサポートする必要はないが、できるようにしてるつもりだったので解決したい
    - 1時間くらいいろいろやって完成！再帰を追うのに疲れた
    - （`direct_declarator`関数に1行`*placeholder = *type;`を追加した）
- TODO: 関数型のパース
- ~~TODO~~: sizeofのアップデート

## 2025-07-28
- 前置++,--を追加
  - `++x`->`x+=1`として変換するか、新しくNodeTagを追加するか
  - できるだけ忠実にASTを組み立てたいので、NodeTagを追加することにする

## 2025-07-29
- 後置++,--を追加

## 2025-07-30
- 剰余演算子（%）を追加

## 2025-07-31
- 配列の初期化（`int a[] = {1,2,3};`）をしたい
  - 初期化子を読む処理を`initializer`関数に分離
  - 単純な配列初期化子を追加
  - TODO: 配列サイズの省略
  - TODO: 入れ子になった初期化子

## 2025-08-01
- グローバル変数の初期化を追加したい

## 2025-08-02
- abstract_declaratorの構文解析を追加し、`sizeof`に複雑な型名を渡せるようになった
- グローバル変数の初期化を追加
  - `Symbol`にinitializerのノードを持たせる
  - TODO: ポインタの初期化子・文字列の代入
  - TODO: 定数式の代入
- 三項演算子を追加

## 2025-08-03
- void型を追加。返り値がvoidの関数が定義できるようになった
- カンマ演算子
- for文の中で宣言
  - TODO: スコープ

# 開発ログ

## 教科書
- [低レイヤを知りたい人のためのCコンパイラ作成入門（CompilerBook）](https://www.sigbus.info/compilerbook#)
- [新・標準プログラマーズライブラリC言語 ポインタ完全制覇（ポインタ完全制覇）](https://gihyo.jp/book/2017/978-4-7741-9381-6)

## 2025-07-02
- 電卓コンパイラができた
  - 四則演算
  - 括弧による優先順位付け
  - 単項`+`/`-`
- Pratt Parsing
  - https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html
  - https://github.com/bradford-hamilton/monkey-lang/blob/master/parser/parser.go
  - https://github.com/TheAlukard/Pratt-Parsing

## 2025-07-03
- 比較演算子を実装した
- 単項`!`
  - !x <=> x==0
  - x86_64の`cmp`っていろいろなオペランドをとれるのか、すごい
- 代入演算子`=`の構文解析
  - `=`は右結合なのでこのままではうまくいかない
  - YouTubeで[Pratt Parsingのわかりやすいアニメーションと解説](https://youtu.be/0c8b7YfsBKs?si=caL7g6vM6oz02IS4)を見つけた
  - 演算子ごとに左結合か右結合かを指定することでパースできた
- '1<2<3'みたいなのがコンパイルできてしまう
- codegenは明日やる

```sh
% ./kcc 'a=b=1+2+3'
a       TokenTag=15
=       TokenTag=0
b       TokenTag=15
=       TokenTag=0
1       TokenTag=14
+       TokenTag=1
2       TokenTag=14
+       TokenTag=1
3       TokenTag=14
        TokenTag=16
(= a (= b (+ (+ 1 2) 3)))
```

## 2025-07-04
- `NodeList`構造体を作った
- 複数の文`stmt := (expr ';')*`をパースできた
- [CompilerBook ステップ9：1文字のローカル変数](https://www.sigbus.info/compilerbook#ステップ91文字のローカル変数)を読んだ
- テストが通らないと思ったら変数のスタックのアドレス計算式（e.g. rbp-8, rbp-16）が間違ってた
- 1文字のローカル変数を使ったプログラムが動いた。`a=1;b=2;a+b; => 3`

## 2025-07-05
- Lexerで識別子を切り出す処理がバグってる。1文字の時はうまく動いていたけど複数文字になると動かない
  - while文の条件が間違っていた。なぜ今まで気づかなかった…
- 複数文字のローカル変数が使えるようになった
- 'return'キーワードを追加
- `1 2 3;`みたいな誤ったプログラムでエラーを出せるように`is_infix`関数を追加し、構文解析時にチェックする
  - `enum OpPrecedence`に`PREC_NONE = 0`を追加
  - `precedences`配列をトークンの種類数だけ確保するように変更、
    グローバル変数は0で初期化されるので、優先度を指定したトークン以外は`PREC_NONE`になる
  - `precedences[tag]`が`PREC_NONE`か否かで判定
- 関数呼び出しのパースを実装した
  ```sh
  % ./kcc 'func(a, b+c, d);'
  (func a (+ b c) d)
  ```
- `make debug`をできるようにした。
  debug用にビルドしたバイナリの場合は、テストを走らせる前に手動で`make clean`をする

## 2025-07-06
- `printf("%.*s", len, ptr)`で出力する文字列の長さを指定できるらしいので、この書き方に統一
- 引数6個までの関数呼び出しができた
  - ~~TODO~~
    > 関数呼び出しをする前にRSPが16の倍数になっていなければいけません。
  - push/popでrspは8ずつ増減する。カウントする必要がありそう
  - gccを参考にローカル変数のために確保するスタックサイズを16の倍数にアラインメントするよう変更
- if文を実装

## 2025-07-07
- blockを実装

## 2025-07-09
- `gen_stmt`で使うラベルidが被るバグを修正
- while文を追加
- for文を追加
- 関数定義を実装！動いた！
  - Parserは、いまパースしている関数のノード`current_func`を持つ
  - ローカル変数の情報localsは関数ノードが持つことにした
  - 仮引数もローカル変数と同様に扱った
  - TODO: ABIを調べる
  - TODO: 構文解析でセグフォする前にエラーを出したい
    - ブロックの閉じ括弧がないとき
```
fib(n) {
    if(n<=1) return n;
    else return fib(n-1) + fib(n-2);
}
main(){ fib(10); } // => 55
```

## 2025-07-10
- gccの`*=`
  - かける数が定数かつ2の累乗のときは左シフト`sal`に
  - かける数が定数かつ2の累乗に近いときは`sal`と`add`,`sub`の組み合わせにコンパイルされる
  - それ以外は`imul`
  - （とりあえずkccでは全部`imul`にする）
- `+=`,`-=`を実装
- `*=`,`/=`を実装
- RAX, RCX, RDX, RSI, RDI, R8-R11あたりは、caller-saveなので勝手に使ってよさそう
- コメントを実装。字句解析で読み飛ばす

## 2025-07-12
- 単項`&`,`*`を追加。実装はとても楽だった。ポインタ完全に理解した
- 関数呼び出しの時rspを16の倍数にアラインメント
  - ~~rspをpushするとそこでrspが-8されるため、復帰時に+8する必要がある~~
    - 再帰呼び出しでバグった
    - アラインメントを補正する必要がある場合とない場合の2通りの`call`を出力することにした

## 2025-07-13
- 『ポインタ完全制覇』が届いたので、1章を読んだ
- `int`キーワード
- 型を見る（`int` or ポインタ）
  - ポインタ
  - まだ、見ただけで使ってない
- 左辺にderefがある代入文をサポート
- ポインタ型の加算・減算に対応
  - exprを組み立ててから、型チェックをする方針
  - ポインタ型の場合は足す数／引く数を4倍する->`typed_expr`関数
  - ~~直接ASTを編集する~~
  - codegenで対応する方針に変更
  - ~~TODO~~: ptr-ptr
  - `typed_expr`あたりがあんまり綺麗でない気がする
- 学びメモ：intの本音はレジスタの幅ということを踏まえると、汎整数昇格は結構自然な仕様

## 2025-07-14
- `sizeof`演算子を追加
- 『ポインタ完全制覇』を眺める
  - p.186, Fig.3-11 を見て、Nodeに型情報を持たせている現在の実装でよさそうと感じた

## 2025-07-15
- chibiccを参考にリファクタリング
  - 型関係のコードを別ファイル`type.c`に分離したい
- 根ノードを渡すと全ての子ノードを再帰的に型付けする`typed`関数を追加
  - ついでに型の整合性をチェックする
- ~~TODO~~: `+=`,`-=`のポインタ演算対応
- ~~TODO~~: 関数の返り値の型チェック
```
  321 codegen.c
  160 kcc.h
  181 lexer.c
  178 main.c
  453 parser.c
  134 type.c
 1427 total
```
- codegenから不要なコードの出力を削った

## 2025-07-18
- 配列の宣言を追加
- 配列アクセスを追加（`a[i]`は、`*(a+i)`の糖衣構文）
- int型の変数を4byteとして、load/storeするときにサイズを考慮するようにした
- 段々、コードが複雑になっているためリファクタリングを進めたい

## 2025-07-19
- 後置演算子のパースを`expr_postfix`関数にまとめた

## 2025-07-21
- 指摘 ~~TODO~~
  - `int - ptr` はできない
- グローバル変数を追加
- 書き込み可能／不可能`.data`, `.text`
- `ptr - ptr`ができた
  - ~~TODO~~: 場合分けをもうちょっときれいにしたい
- char型を追加した
  - 汎整数昇格の実装はこれでいいのか？（2025-07-23追記：だいぶ間違ってた）
  - char型に関するテストを書いているときに`ch`という関数を定義するとアセンブラがエラーを出して、
    調べてみたらレジスタと名前が衝突してた… TODO:ラベル命名の修正
- 文字列リテラルのtokenizeだけ
  - TODO: エスケープシーケンス

## 2025-07-22
- codegen.cの`gen_expr`関数を分割

## 2025-07-23
- 文字列を追加
  - 文字列が出てきたらParserの`string_tokens`リストに追加。インデックスをIDとする。インデックスはノードに保存しておく
  - 文字列はchar型の配列
  - 式の中で配列は先頭要素へのポインタに読み替えられる
- 計算するときにcharをintに読み替えるようにする
- `typed`関数を修正
- 関数が返す型を考慮するようになった
  - 関数の名前と返す値をメモっておき、型チェック時に利用
  - 知らない関数は`int`型を返すと仮定
- テストケースの修正
- `sizeof(int)`, `sizeof(char)`を書けるようにした
  - ~~TODO~~: `sizeof(int*)`
- 文字列の長さを考えるとき'\0'を忘れていたため修正

## 2025-07-24
- `Var`という構造体に関数の情報を保存するのはあまり見栄えがよくないため、`Symbol`にリネーム
  - 記号表（symbol table）を意識して命名したが、もっといい名前を思いついたら変更したい
- 関数がポインタ型を返すことを確かめるテストを追加

| step／データ | トークン | AST | 関数返り値型表 | ローカル変数表 | グローバル変数表 | 文字列表 |
| - | - | - | - | - | :- | - |
| 字句解析 | 作る | - | - | - | - | - |
| 構文解析 | 〇 | 作る | 作る | 作る | 作る | 作る |
| 意味解析（型チェック） | 〇 | 〇 | 〇 | 〇 | 〇 | × |
| アセンブリコード生成 | 〇 | 〇 | × | 〇 | 〇 | 〇 |

- `parse`関数の返り値を`struct Program`としてまとめた
- `sizeof(int*)`のようなポインタ型に対する`sizeof`を追加
- ソースコードの入力をファイルからの入力 or 標準入力に変更

## 2025-07-26
- ローカル変数の宣言と初期化ができるようになった
  - declarationの構文が難しい…
  - とりあえず動くものを作ることを優先
- ~~TODO~~: 配列の配列、括弧を使った優先順位付け
  - 2時間くらい試行錯誤した（wipとしてコミットしたやつ）が、うまくいかなかったのでCompilerBookをちゃんと読み直すと以下の記述を見つけた
  - > ネストした型がある場合、カッコの中の型と外の型を別々に構文解析して、後でそれを組み合わせることにより、全体の型を得ることができます。（CompilerBook Cの型の構文）
  - さらに1時間くらいコードを書いたが完成しなかったので他の人のコードを見て学ぶことにした
  - [9ccのパーサ](https://github.com/rui314/9cc/blob/ea2f4b8bdedef70dc9e1dcbf99c255c94e0fa2fe/parse.c#L654)を参考にして実装できた
  - と思ったら`int (hoge);`みたいな（別にいらない）括弧が付いた宣言が通らない
    - 別にサポートする必要はないが、できるようにしてるつもりだったので解決したい
    - 1時間くらいいろいろやって完成！再帰を追うのに疲れた
    - （`direct_declarator`関数に1行`*placeholder = *type;`を追加した）
- TODO: 関数型のパース
- ~~TODO~~: sizeofのアップデート

## 2025-07-28
- 前置++,--を追加
  - `++x`->`x+=1`として変換するか、新しくNodeTagを追加するか
  - できるだけ忠実にASTを組み立てたいので、NodeTagを追加することにする

## 2025-07-29
- 後置++,--を追加

## 2025-07-30
- 剰余演算子（%）を追加

## 2025-07-31
- 配列の初期化（`int a[] = {1,2,3};`）をしたい
  - 初期化子を読む処理を`initializer`関数に分離
  - 単純な配列初期化子を追加
  - TODO: 配列サイズの省略
  - TODO: 入れ子になった初期化子
  - TODO: `x[i][j]`みたいなやつ

## 2025-08-01
- グローバル変数の初期化を追加したい

## 2025-08-02
- abstract_declaratorの構文解析を追加し、`sizeof`に複雑な型名を渡せるようになった
- グローバル変数の初期化を追加
  - `Symbol`にinitializerのノードを持たせる
  - TODO: ポインタの初期化子・文字列の代入
  - TODO: 定数式の代入
- 三項演算子を追加

## 2025-08-03
- void型を追加。返り値がvoidの関数が定義できるようになった
- カンマ演算子
- for文の中で宣言
  - TODO: スコープ
  - ~~TODO~~: `for(;;);`みたいに空の時に出力されるアセンブリが変。直す
- 論理和・論理積を追加
- [ドーナツ](https://sozysozbot.github.io/seccamp-2022-c-compiler-seminar/#permalink_2d4df40be11b02e75bdfb006d357d3ad)が動いた
  - プロトタイプ宣言・エスケープシーケンスは非対応
  - #includeはgccに任せている

## 2025-08-05
- 大学の期末試験が終わった！

## 2025-08-07
- `struct`をパース

## 2025-08-08
- ローカル変数で`struct`が使えるようになった
- メモリ上での配置を考えるのに時間がかかった
    - スタックはマイナス方向に伸びる
    - ローカル変数は変数の型のサイズの分だけrbpからのオフセットを持つ
    - `rbp - offset`がローカル変数のベースアドレス
    - 例えばint型の値はベースアドレスから正の方向4番地分に格納されている
    - 構造体を定義された順にメモリに格納したい
    - パースしたとき連結リストが逆順になっているので反転
    - 反転させた後、offsetを割り当てるようにした
    - 構造体のメンバにアクセスするときはoffsetを足し算する
- ついでにグローバル変数も同様に逆順になっていたので反転
- ~~TODO~~: アラインメントが適当なのを直す。8byteのポインタ型のメンバがあるとき正しく動作しない気がする

## 2025-08-10
- セキュリティ・キャンプ会場に到着し前泊。鉄道の乗り換えで迷う
- ~~TODO~~: ポインタ型の論理否定
  - ちゃんとqwordにしていたのを確認（2025-08-11）
- アラインメントについて
  - hsjoihs「アラインメントの基本原則は2つで、『アラインメントが最大のメンバのアラインメントが採用される』『型のポインタのアドレスは、常にアラインメントの倍数』です」
- 構造体の大きさの分だけ`.zero size`することでグローバルな構造体定義に対応
- アロー演算子を追加
- 入れ子の構造体に対応
- 型チェックをする`is_compatible`関数を修正

## 2025-08-11
- 文字リテラルを追加
- `const`を読むが、無視する
- 引数が無い関数に`void`を指定できるように
- セキュキャン2025 1日目の記録
  - 共通講義K2『物語の力で情報セキュリティを発信するということ ～アニメ「こうしす！」を例に～』
    - 自主制作アニメ「こうしす！」について
    - ニコニコ動画で見たやつ！
    - ソフトウェア開発と通じるところがめっちゃある
  - 共通講義K1『法律と倫理』
    - 検事の方の講演を伺った
    - 法律もプログラムみたいなものという視点はすごい納得
  - Cコンパイラゼミ同期の[椎名さん](https://x.com/s7tya)とNOC部屋で遭遇し雑談
  - ゼミ同期の[ゃーさん](https://x.com/reversed_R)からデバッグ用のゴム製アヒルをもらう。
    ありがとう！
  - [hsjoihs先生](https://x.com/hsjoihs)に挨拶
- プロトタイプ宣言的なものに対応
  - 返り値のみ見ている
- 型チェックの杜撰な部分を見つけて更新したが、依然として杜撰

## 2025-08-12
- 2kmccをコンパイルしたい
- デバッグ記録
  - kccで2kmccをコンパイルし、アセンブリが出力された。
    kccでコンパイルした2kmccでプログラムをコンパイルすると、文字列が正しく出力されない。
    例えば、以下の例ではmain関数の`main`が`m`しか出力されていない。
    
    ```
     % ./2kmcc 'int main() {return 0;}'
    .intel_syntax noprefix
      .text
      .section .rodata
      .text
    .text
    .globl m
    m:
      push rbp
      mov rbp, rsp
      sub rsp, 0
      mov rax, 1
      mov rax, 0
      mov rsp, rbp
      pop rbp
      ret
      mov rax, 42
      mov rsp, rbp
      pop rbp
      ret
    ```
    
    関数名を出力している2kmccのソースコードはこのあたり。

    ```
    struct NameAndType {
        char *name;
        struct Type *type;
    };
    struct NameAndType *global_vars_start[100];
    printf(".globl %s\n", global_vars_start[i]->name);
    ```
    
    エラーが再現する最小ケースを探したい。
    - 配列アクセスがだめ？
    - アロー演算子がだめ？
    - 組み合わせるとだめ？
    
    このケースが通らないことが分かった。

    ```
    int main() {
        int **tests = calloc(2, sizeof(int*));
        tests[1] = calloc(3, sizeof(int));
        tests[1][1] = 4;
        return tests[1][1] + 5;
    }
    ```
    
    - uchan先生からのアドバイス
      - gdbの`-x`オプションでスクリプトを書いておくとデバッグ時に便利
      - codegenでprintfをしておくとアセンブリが読みやすくなる
    
    アセンブリを読むと、64bitのアドレスを保存したいのに`mov [rdi], eax`となっており、おかしいことが分かった。
    `int**`を一度デリファレンスしたものがintに判定されている？？
    
    型情報がおかしいため、type.cの誤りを探す。
    assignの型付けを変えるとテストケースは通った！
  - kccでコンパイルした2kmccの文字列出力が不完全な問題は解決せず。
    ここで`name`メンバ変数に代入されているが、関係ある？
    ```
    struct NameAndType *consume_type_and_ident_1st_half() {
        struct Type *type = consume_simple_type();
        expect_otherwise_panic(enum4('I', 'D', 'N', 'T'));
        char *name = (tokens_cursor++)->identifier_name_or_escaped_string_content;
        struct NameAndType *ans = calloc(1, sizeof(struct NameAndType));
        ans->name = name;
        ans->type = type;
        return ans;
    }
    ```
  - k_kiri「kccでコンパイルした2kmccの文字列出力が不完全な問題は今だ解決せず」
    hsjoihs「『その問題を残したまま、どこまで削れるか？』ってやってみましたか？ minimize と言います」
    k_kiri「やってないです」
  - やった。2kmccを関係箇所のみ64行まで削る。
  - 2kmccのプログラム中にポインタ同士の減算を発見。そういえば、サボってint型しか対応してなかった
  - ポインタ同士の減算を実装すると、2kmccがコンパイルできた
- break, continueを追加
- コード生成で使用するデータを`GenContext`構造体にまとめるように変更
  - `type.c`ではこれまで通りデータを`Env`で持つ
  - `codegen.c`で使うデータは`GenContext`
- セキュキャン2025 2日目の記録
  - （午前中） デバッグ
  - （昼） デバッグ
  - （15:53） 2kmccのコンパイルに成功
  - （夕方） break, continue, do-while
  - （夜） 共通講義・LT大会

## 2025-08-13
- switch, caseを追加
  - `jg`命令を使うgcc賢い
  - `default`ラベルが最初に来てもOK
  - codegenをあまり綺麗に実装できなかった
- unionを追加
  - ほとんどstructからコピペし、offsetを0にする
  - TODO: struct内の無名union
  - 無名共用体を追加。ついでに無名構造体も
    - テストはChatGPTに手伝って書いてもらった

## セルフホストに向けたTODOまとめ
  - [x] continue, break
  - [x] do while
  - [x] switch, case
  - [x] union
  - [ ] enum
  - [ ] typedef
  - [ ] 構造体の初期化子
  - [ ] #define
  - [ ] #include
  - [ ] エラー出力
  - [ ] 文字列中のエスケープ処理
  - [ ] 関数型のパース
